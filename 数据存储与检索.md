# 数据库核心：数据结构

-------------

## 哈希索引

### Bitcask（Riak中的默认存储引擎）

- 提供了高性能的读写
- **高性能读写**：针对文件写入采用追加操作
- **磁盘空间优化**：采用日志分段方案，定期进行压缩，保留键值的最新状态
  - 采用辅助线程进行压缩，压缩成功后，再将原始数据删除

### 实现

- 文件格式：最好使用二进制格式，不需要转义  ===>  Flink Spark也曾使用了这种方案，保证自己的数据处理速度
- 删除记录：墓碑标记，合并日志段的时候根据墓碑删除数据 ===> HBase
- 崩溃恢复：快照方案  ===> Flink Spark
- 部分写入记录： 根据校验值丢弃损坏部分  ===>Hadoop
- 并发控制：单线程写入，多线程读取

### 为什么使用追加方案

- 顺序读写速度更快 ==> Kafka
- 崩溃恢复的时候，不必考虑新值与旧值混在一起
- 合并旧段可以避免数据文件的碎片化问题

### 哈希表索引局限性

- 冲突问题
- 必须放入内存
- 无法实现区间查询

## SSTables和LSM-Tree

### SSTables	排序字符串表

- kv键值对的顺序按照键值进行排序
- 每个键在每个合并的段文件中只能出现一次

#### **优点**

- 合并高效
- 查找特定的键的时候可以根据排序查找

#### 如何维护和构建SSTables

- 写入的时候数据保存到平衡树数据结构中
- 当内存数据达到阈值，写入磁盘
- 查询时先查内存再查磁盘
- 后台进程周期性的压缩和删除日志数据

### SSTables 向 LSM-Tree演化

- LSM-Tree 索引结构

### 性能优化

- 布隆过滤器
- 针对不同的场景，对SSTable使用不同的压缩和合并策略

## B-trees

- 节点存放索引值和数据
- 采用WAL方案实现崩溃恢复
- 需要进行并发控制，保证多线程安全

### 优化方案

- 写时复制方案
- 非叶子节点不存放数据
- 尽可能满足局部性原理

## B-tree 对比 LSM-tree

- B树读速度更快，LSM写速度快
- LSM树具有较低的写放大
- LSM树可以更好的进行压缩

# 事务处理与分析处理

----------

## OLTP与OLAP对比

![image-20220327212340857](C:\Users\feng\AppData\Roaming\Typora\typora-user-images\image-20220327212340857.png)

## 数据仓库

- 数据仓库包含所有OLTP数据库的只读副本

## OLTP数据库和数据仓库之间的差异

- 二者针对不同的查询模式进行了优化
  - OLTP更倾向于复杂查询、关联查询

# 列式存储

-------

- 面向压缩友好，每一列的数据类型相同，可以针对不同的列采用不同的压缩方案
- 更高效的利用CPU，可以将一大块压缩列数据放入CPU缓存中

## 写操作

- LSM-tree解决方案





























